// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny


package resource

import (
	"reflect"

	"github.com/aelsabbahy/goss/system"
)

//go:generate sed -i -e "/^\\/\\/ +build genny/d" resource_list.go

type AddrSlice []*Addr

func (r *AddrSlice) Append(ne *Addr) bool {
	for _, ele := range *r {
		if reflect.DeepEqual(ele, ne) {
			return false
		}
	}
	*r = append(*r, ne)
	return true
}

func (r *AddrSlice) AppendSysResource(sr string, sys *system.System) (*Addr, system.Addr, bool) {
	sysres := sys.NewAddr(sr, sys)
	res := NewAddr(sysres)
	ok := r.Append(res)
	return res, sysres, ok
}

func (r *AddrSlice) AppendSysResourceIfExists(sr string, sys *system.System) (*Addr, system.Addr, bool) {
	sysres := sys.NewAddr(sr, sys)
	res := NewAddr(sysres)
	if e, _ := sysres.Exists(); e != true {
		return res, sysres, false
	}
	ok := r.Append(res)
	return res, sysres, ok
}


//go:generate sed -i -e "/^\\/\\/ +build genny/d" resource_list.go

type CommandSlice []*Command

func (r *CommandSlice) Append(ne *Command) bool {
	for _, ele := range *r {
		if reflect.DeepEqual(ele, ne) {
			return false
		}
	}
	*r = append(*r, ne)
	return true
}

func (r *CommandSlice) AppendSysResource(sr string, sys *system.System) (*Command, system.Command, bool) {
	sysres := sys.NewCommand(sr, sys)
	res := NewCommand(sysres)
	ok := r.Append(res)
	return res, sysres, ok
}

func (r *CommandSlice) AppendSysResourceIfExists(sr string, sys *system.System) (*Command, system.Command, bool) {
	sysres := sys.NewCommand(sr, sys)
	res := NewCommand(sysres)
	if e, _ := sysres.Exists(); e != true {
		return res, sysres, false
	}
	ok := r.Append(res)
	return res, sysres, ok
}


//go:generate sed -i -e "/^\\/\\/ +build genny/d" resource_list.go

type DNSSlice []*DNS

func (r *DNSSlice) Append(ne *DNS) bool {
	for _, ele := range *r {
		if reflect.DeepEqual(ele, ne) {
			return false
		}
	}
	*r = append(*r, ne)
	return true
}

func (r *DNSSlice) AppendSysResource(sr string, sys *system.System) (*DNS, system.DNS, bool) {
	sysres := sys.NewDNS(sr, sys)
	res := NewDNS(sysres)
	ok := r.Append(res)
	return res, sysres, ok
}

func (r *DNSSlice) AppendSysResourceIfExists(sr string, sys *system.System) (*DNS, system.DNS, bool) {
	sysres := sys.NewDNS(sr, sys)
	res := NewDNS(sysres)
	if e, _ := sysres.Exists(); e != true {
		return res, sysres, false
	}
	ok := r.Append(res)
	return res, sysres, ok
}


//go:generate sed -i -e "/^\\/\\/ +build genny/d" resource_list.go

type FileSlice []*File

func (r *FileSlice) Append(ne *File) bool {
	for _, ele := range *r {
		if reflect.DeepEqual(ele, ne) {
			return false
		}
	}
	*r = append(*r, ne)
	return true
}

func (r *FileSlice) AppendSysResource(sr string, sys *system.System) (*File, system.File, bool) {
	sysres := sys.NewFile(sr, sys)
	res := NewFile(sysres)
	ok := r.Append(res)
	return res, sysres, ok
}

func (r *FileSlice) AppendSysResourceIfExists(sr string, sys *system.System) (*File, system.File, bool) {
	sysres := sys.NewFile(sr, sys)
	res := NewFile(sysres)
	if e, _ := sysres.Exists(); e != true {
		return res, sysres, false
	}
	ok := r.Append(res)
	return res, sysres, ok
}


//go:generate sed -i -e "/^\\/\\/ +build genny/d" resource_list.go

type GossfileSlice []*Gossfile

func (r *GossfileSlice) Append(ne *Gossfile) bool {
	for _, ele := range *r {
		if reflect.DeepEqual(ele, ne) {
			return false
		}
	}
	*r = append(*r, ne)
	return true
}

func (r *GossfileSlice) AppendSysResource(sr string, sys *system.System) (*Gossfile, system.Gossfile, bool) {
	sysres := sys.NewGossfile(sr, sys)
	res := NewGossfile(sysres)
	ok := r.Append(res)
	return res, sysres, ok
}

func (r *GossfileSlice) AppendSysResourceIfExists(sr string, sys *system.System) (*Gossfile, system.Gossfile, bool) {
	sysres := sys.NewGossfile(sr, sys)
	res := NewGossfile(sysres)
	if e, _ := sysres.Exists(); e != true {
		return res, sysres, false
	}
	ok := r.Append(res)
	return res, sysres, ok
}


//go:generate sed -i -e "/^\\/\\/ +build genny/d" resource_list.go

type GroupSlice []*Group

func (r *GroupSlice) Append(ne *Group) bool {
	for _, ele := range *r {
		if reflect.DeepEqual(ele, ne) {
			return false
		}
	}
	*r = append(*r, ne)
	return true
}

func (r *GroupSlice) AppendSysResource(sr string, sys *system.System) (*Group, system.Group, bool) {
	sysres := sys.NewGroup(sr, sys)
	res := NewGroup(sysres)
	ok := r.Append(res)
	return res, sysres, ok
}

func (r *GroupSlice) AppendSysResourceIfExists(sr string, sys *system.System) (*Group, system.Group, bool) {
	sysres := sys.NewGroup(sr, sys)
	res := NewGroup(sysres)
	if e, _ := sysres.Exists(); e != true {
		return res, sysres, false
	}
	ok := r.Append(res)
	return res, sysres, ok
}


//go:generate sed -i -e "/^\\/\\/ +build genny/d" resource_list.go

type PackageSlice []*Package

func (r *PackageSlice) Append(ne *Package) bool {
	for _, ele := range *r {
		if reflect.DeepEqual(ele, ne) {
			return false
		}
	}
	*r = append(*r, ne)
	return true
}

func (r *PackageSlice) AppendSysResource(sr string, sys *system.System) (*Package, system.Package, bool) {
	sysres := sys.NewPackage(sr, sys)
	res := NewPackage(sysres)
	ok := r.Append(res)
	return res, sysres, ok
}

func (r *PackageSlice) AppendSysResourceIfExists(sr string, sys *system.System) (*Package, system.Package, bool) {
	sysres := sys.NewPackage(sr, sys)
	res := NewPackage(sysres)
	if e, _ := sysres.Exists(); e != true {
		return res, sysres, false
	}
	ok := r.Append(res)
	return res, sysres, ok
}


//go:generate sed -i -e "/^\\/\\/ +build genny/d" resource_list.go

type PortSlice []*Port

func (r *PortSlice) Append(ne *Port) bool {
	for _, ele := range *r {
		if reflect.DeepEqual(ele, ne) {
			return false
		}
	}
	*r = append(*r, ne)
	return true
}

func (r *PortSlice) AppendSysResource(sr string, sys *system.System) (*Port, system.Port, bool) {
	sysres := sys.NewPort(sr, sys)
	res := NewPort(sysres)
	ok := r.Append(res)
	return res, sysres, ok
}

func (r *PortSlice) AppendSysResourceIfExists(sr string, sys *system.System) (*Port, system.Port, bool) {
	sysres := sys.NewPort(sr, sys)
	res := NewPort(sysres)
	if e, _ := sysres.Exists(); e != true {
		return res, sysres, false
	}
	ok := r.Append(res)
	return res, sysres, ok
}


//go:generate sed -i -e "/^\\/\\/ +build genny/d" resource_list.go

type ProcessSlice []*Process

func (r *ProcessSlice) Append(ne *Process) bool {
	for _, ele := range *r {
		if reflect.DeepEqual(ele, ne) {
			return false
		}
	}
	*r = append(*r, ne)
	return true
}

func (r *ProcessSlice) AppendSysResource(sr string, sys *system.System) (*Process, system.Process, bool) {
	sysres := sys.NewProcess(sr, sys)
	res := NewProcess(sysres)
	ok := r.Append(res)
	return res, sysres, ok
}

func (r *ProcessSlice) AppendSysResourceIfExists(sr string, sys *system.System) (*Process, system.Process, bool) {
	sysres := sys.NewProcess(sr, sys)
	res := NewProcess(sysres)
	if e, _ := sysres.Exists(); e != true {
		return res, sysres, false
	}
	ok := r.Append(res)
	return res, sysres, ok
}


//go:generate sed -i -e "/^\\/\\/ +build genny/d" resource_list.go

type ServiceSlice []*Service

func (r *ServiceSlice) Append(ne *Service) bool {
	for _, ele := range *r {
		if reflect.DeepEqual(ele, ne) {
			return false
		}
	}
	*r = append(*r, ne)
	return true
}

func (r *ServiceSlice) AppendSysResource(sr string, sys *system.System) (*Service, system.Service, bool) {
	sysres := sys.NewService(sr, sys)
	res := NewService(sysres)
	ok := r.Append(res)
	return res, sysres, ok
}

func (r *ServiceSlice) AppendSysResourceIfExists(sr string, sys *system.System) (*Service, system.Service, bool) {
	sysres := sys.NewService(sr, sys)
	res := NewService(sysres)
	if e, _ := sysres.Exists(); e != true {
		return res, sysres, false
	}
	ok := r.Append(res)
	return res, sysres, ok
}


//go:generate sed -i -e "/^\\/\\/ +build genny/d" resource_list.go

type UserSlice []*User

func (r *UserSlice) Append(ne *User) bool {
	for _, ele := range *r {
		if reflect.DeepEqual(ele, ne) {
			return false
		}
	}
	*r = append(*r, ne)
	return true
}

func (r *UserSlice) AppendSysResource(sr string, sys *system.System) (*User, system.User, bool) {
	sysres := sys.NewUser(sr, sys)
	res := NewUser(sysres)
	ok := r.Append(res)
	return res, sysres, ok
}

func (r *UserSlice) AppendSysResourceIfExists(sr string, sys *system.System) (*User, system.User, bool) {
	sysres := sys.NewUser(sr, sys)
	res := NewUser(sysres)
	if e, _ := sysres.Exists(); e != true {
		return res, sysres, false
	}
	ok := r.Append(res)
	return res, sysres, ok
}
